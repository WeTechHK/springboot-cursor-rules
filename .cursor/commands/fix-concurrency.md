# /fix-concurrency 命令

## 命令格式
```bash
/fix-concurrency [一段描述性的话]
```

## 功能说明
修复并发问题，包括并发问题分析、并发控制方案、线程安全实现、并发测试验证和并发监控配置。

## AI分析流程

### 1. 智能描述解析
- **提取关键信息**：从用户描述中提取并发问题、影响范围、并发类型
- **识别问题类型**：判断是并发冲突、死锁、竞态条件、线程安全等
- **推断修复复杂度**：基于描述推断修复的复杂度和影响范围

### 2. 智能文档发现
- **自动扫描**：扫描项目根目录下的`docs/`目录中的并发文档、性能文档、监控文档
- **内容匹配**：基于描述内容匹配相关并发文档
- **信息提取**：从文档中提取并发策略、监控配置、测试方案等
- **文件显示**：在AI响应中显示找到的相关设计文件名，便于用户确认

### 3. 基于项目结构的智能推断
- **项目分析**：分析现有项目的并发处理、技术栈、架构设计
- **问题识别**：识别相关并发问题和优化点
- **规范推断**：推断项目的并发控制规范

### 4. 并发修复规则匹配
- **规范匹配**：根据需求匹配对应的并发控制规范
- **修复策略**：应用并发控制策略和最佳实践
- **代码生成**：生成符合项目规范的并发控制代码

### 5. 主动询问机制
- **问题补全**：识别缺失或模糊的并发问题，主动询问用户
- **方案确认**：确认并发控制方案和监控要求
- **多轮对话**：支持多轮对话，逐步完善修复方案

## 使用示例

### 1. 简单描述
```bash
/fix-concurrency 订单创建并发冲突问题
```

### 2. 详细描述
```bash
/fix-concurrency 订单创建并发冲突问题，多个用户同时创建订单导致数据不一致
```

### 3. 业务场景描述
```bash
/fix-concurrency 库存扣减并发问题，高并发下库存可能出现超卖
```

### 4. 技术需求描述
```bash
/fix-concurrency 用户注册并发问题，需要防止重复注册和用户名冲突
```

## AI交互示例

### 示例1：简单描述
```bash
# 用户输入
/fix-concurrency 订单创建并发冲突问题

# AI响应
AI: 已解析您的描述"订单创建并发冲突问题"，并发现以下相关文档：

**发现的设计文档：**
- `docs/concurrency-control.md` - 并发控制文档
- `docs/order-business-logic.md` - 订单业务逻辑文档
- `docs/performance-optimization.md` - 性能优化文档

基于这些文档，将针对以下并发问题进行修复：

**推断的并发问题：**
- 订单号重复生成
- 库存并发扣减冲突
- 订单状态并发更新
- 支付状态并发修改

**需要确认的信息：**
1. 具体是哪种并发冲突？
2. 并发量大概多少？
3. 是否使用了分布式锁？
4. 是否需要数据库锁？
5. 是否需要乐观锁？

请提供详细信息，或者确认我的推断是否正确？
```

### 示例2：详细描述
```bash
# 用户输入
/fix-concurrency 订单创建并发冲突问题，多个用户同时创建订单导致数据不一致

# AI响应
AI: 已解析您的详细描述，将针对订单创建并发冲突问题进行修复：

**发现的设计文档：**
- `docs/concurrency-control.md` - 并发控制文档
- `docs/order-business-logic.md` - 订单业务逻辑文档
- `docs/database-optimization.md` - 数据库优化文档

**解析的修复方案：**
1. 并发问题分析
   - 订单号生成并发冲突
   - 库存扣减并发冲突
   - 订单状态更新冲突
   - 数据一致性保证

2. 并发控制方案
   - 使用分布式锁控制订单创建
   - 使用乐观锁控制库存扣减
   - 使用数据库事务保证一致性
   - 使用消息队列异步处理

3. 代码实现
   - 添加分布式锁注解
   - 实现乐观锁版本控制
   - 优化事务边界
   - 添加并发监控

**需要确认的信息：**
1. 当前使用的锁机制？
2. 是否需要分布式锁？
3. 数据库隔离级别？
4. 是否需要异步处理？

请确认以上信息是否正确，或者提供更多详细信息？
```

## 修复内容

### 1. 并发问题分析
- 并发问题识别
- 并发问题根因分析
- 并发影响评估
- 并发控制目标

### 2. 并发控制方案
- 并发控制策略设计
- 线程安全实现方案
- 锁机制设计
- 并发控制风险评估

### 3. 并发控制实现
- 线程安全代码实现
- 锁机制实现
- 并发控制逻辑
- 异常处理机制

### 4. 并发测试用例
- 并发测试场景
- 压力测试用例
- 死锁测试用例
- 并发回归测试

### 5. 并发监控配置
- 并发指标监控
- 死锁监控配置
- 并发性能监控
- 并发告警配置

## 并发问题类型

### 1. 并发冲突问题
- `DataConflict` - 数据并发修改冲突
- `BusinessConflict` - 业务状态并发冲突
- `ResourceConflict` - 资源并发访问冲突
- `TransactionConflict` - 事务并发冲突

### 2. 死锁问题
- `DatabaseDeadlock` - 数据库死锁
- `ApplicationDeadlock` - 应用层死锁
- `ResourceDeadlock` - 资源死锁
- `CircularDeadlock` - 循环等待死锁

### 3. 竞态条件问题
- `ConditionRace` - 条件检查竞态
- `StateRace` - 状态更新竞态
- `ResourceRace` - 资源分配竞态
- `TimingRace` - 时序依赖竞态

### 4. 线程安全问题
- `SharedDataAccess` - 共享数据访问
- `NonAtomicOperation` - 非原子操作
- `MemoryVisibility` - 内存可见性问题
- `InstructionReordering` - 指令重排序问题

## 并发控制策略

### 1. 锁机制
- 悲观锁控制
- 乐观锁控制
- 分布式锁控制
- 读写锁控制

### 2. 事务控制
- 事务隔离级别
- 事务传播行为
- 事务回滚机制
- 分布式事务

### 3. 并发数据结构
- 线程安全集合
- 原子操作类
- 并发队列
- 并发映射

### 4. 异步处理
- 异步任务处理
- 消息队列处理
- 事件驱动处理
- 响应式编程

## 并发控制特性
1. **安全性**: 保证并发操作的安全性
2. **一致性**: 保证数据的一致性
3. **性能**: 优化并发性能
4. **可监控**: 并发监控和告警
5. **可维护**: 并发控制代码可维护

## 技术实现
- **锁**: 使用synchronized、ReentrantLock等
- **原子**: 使用Atomic类、CAS操作
- **事务**: 使用Spring事务管理
- **异步**: 使用@Async、CompletableFuture
- **监控**: 并发监控和告警

## 注意事项
1. AI会根据描述自动推断并发问题
2. 自动分析并发根因和影响范围
3. 提供具体的并发控制方案
4. 遵循项目的编码规范和并发规范
5. 生成的代码可以直接运行和测试
6. 支持多轮对话完善需求
7. 支持文档引用和智能推断
8. 支持自然语言描述

## 最佳实践建议

### 1. 描述技巧
- **具体描述**: 提供详细的并发问题描述，AI能更好地理解需求
- **关键场景**: 包含具体的并发场景和影响
- **性能要求**: 指定并发性能要求和约束条件

### 2. 交互技巧
- **分步确认**: 先确认核心问题，再完善修复方案
- **及时反馈**: 对AI的推断及时提供反馈
- **迭代优化**: 基于修复结果进行迭代改进

### 3. 文档使用
- **并发文档**: 在项目中维护并发文档，AI会自动发现
- **性能文档**: 维护性能文档，AI会参考生成监控配置
- **业务文档**: 维护业务文档，AI会参考生成业务并发控制