# Spring Boot Cursor Rules

> **文件说明**：这是一个精简的 Spring Boot Cursor Rules 配置文件，为 Cursor AI 提供项目的核心上下文信息，包括以下内容：
> - 项目概述（企业级应用开发规范）
> - 技术栈（核心技术栈、可选技术栈）
> - 核心开发原则（代码质量、Spring Boot 最佳实践、数据库设计、安全考虑）
> - 代码生成规则（Controller 层、Service 层、Entity 层）
> - 命名约定（包命名、类命名、方法命名）
> - 错误处理（统一响应格式、异常处理）
> - 测试要求（单元测试、集成测试）
> - 性能要求（数据库查询、缓存策略）
> - 安全要求（输入验证、权限控制）
> - 文档要求（API 文档、代码文档）
> - 部署要求（环境配置、监控告警）
> 
> 此文件是 Cursor AI 理解项目结构和要求的基础，建议在项目根目录中保持同步更新。适用于所有使用 Cursor AI 进行 Spring Boot 开发的团队成员。

# Spring Boot Cursor Rules

## 项目概述
这是一个基于 Spring Boot 3.x 的企业级应用开发规范。本项目使用现代化的 Java 技术栈，遵循企业级开发最佳实践。

## 技术栈
- **Java**: OpenJDK 17+
- **框架**: Spring Boot 3.x, Spring Security, Spring Data JPA
- **构建工具**: Gradle 8.x / Maven 3.x
- **数据库**: MySQL 8.0+ / PostgreSQL / H2 (测试)
- **ORM**: MyBatis / JPA
- **工具库**: Lombok, MapStruct, Hutool
- **文档**: SpringDoc OpenAPI (Swagger)
- **测试**: JUnit 5, Spring Boot Test, Mockito

## 可选技术栈
根据项目需求，可以选择以下技术：
- **工作流引擎**: Activiti / Camunda (需要审批流程时)
- **消息队列**: RabbitMQ / Apache Kafka (需要异步处理时)
- **缓存**: Redis (需要缓存时)
- **搜索引擎**: Elasticsearch (需要全文搜索时)
- **监控**: Micrometer + Prometheus (需要监控时)

## 核心开发原则

### 1. 代码质量
我们追求高质量、可维护的代码，这不仅是技术问题，更是团队协作的基础。

**SOLID原则**：这是面向对象设计的五大基本原则，确保代码的灵活性和可扩展性。单一职责原则让每个类只做一件事，开闭原则让系统对扩展开放、对修改关闭，里氏替换原则确保子类可以替换父类，接口隔离原则避免臃肿的接口，依赖倒置原则让高层模块不依赖低层模块。

**有意义的命名**：变量、方法、类名应该清楚地表达其用途和意图。好的命名可以减少注释的需要，让代码自文档化。避免使用缩写、数字后缀或过于通用的名称。

**方法简洁性**：每个方法应该专注于一个功能，长度控制在 50 行以内。长方法往往包含多个职责，难以理解和测试。如果方法过长，考虑拆分为多个小方法。

**自文档化代码**：通过清晰的命名、合理的结构和适当的注释，让代码能够自我解释。代码应该像散文一样易读，让其他开发者能够快速理解其意图。

**组合优于继承**：优先使用组合（has-a）而不是继承（is-a）来扩展功能。组合更加灵活，避免了继承带来的紧耦合问题。

### 2. Spring Boot 最佳实践
Spring Boot 提供了丰富的特性，正确使用这些特性能够显著提升开发效率和代码质量。

**构造器注入**：相比字段注入，构造器注入更加安全、明确，且支持不可变字段。它强制我们在创建对象时就提供所有依赖，避免了空指针异常。

**事务管理**：@Transactional 注解是数据一致性的重要保障。理解不同的事务传播行为和隔离级别，根据业务需求选择合适的配置。记住，事务不是银弹，过度使用会影响性能。

**RESTful API 设计**：遵循 REST 架构风格，使用 HTTP 动词表达操作意图，通过 URL 路径表达资源层次。好的 API 设计让客户端能够直观地理解和使用。

**参数验证**：使用 @Valid 注解和 Bean Validation 规范进行参数验证，在数据进入业务逻辑之前就确保其有效性。这是防御性编程的重要实践。

**全局异常处理**：通过 @ControllerAdvice 统一处理异常，避免在每个控制器中重复异常处理逻辑。这不仅能减少代码重复，还能提供一致的错误响应格式。

### 3. 数据库设计
数据库设计直接影响应用的性能、可维护性和数据一致性。

**命名约定**：遵循一致的命名规范，使用下划线分隔单词，表名使用复数形式。好的命名让数据库结构一目了然。

**索引设计**：合理设计索引是查询性能的关键。为经常查询的字段创建索引，但避免过多索引影响写入性能。理解复合索引的最左前缀原则。

**事务管理**：使用事务确保数据的一致性，理解 ACID 特性。在微服务架构中，考虑分布式事务的复杂性。

**查询优化**：避免 N+1 查询问题，使用批量查询和适当的关联查询。理解查询执行计划，优化慢查询。

### 4. 安全考虑
安全不是事后考虑的问题，而是从设计阶段就要考虑的重要因素。

**输入验证**：所有外部输入都可能是恶意的，必须进行严格的验证。使用白名单验证，拒绝所有不在预期范围内的输入。

**SQL 注入防护**：使用参数化查询或 ORM 框架的查询方法，永远不要直接拼接 SQL 字符串。这是最基本但最重要的安全实践。

**权限控制**：实现基于角色的访问控制（RBAC），确保用户只能访问其权限范围内的资源。使用 Spring Security 等成熟框架。

**敏感信息保护**：对敏感数据进行加密存储，在日志中避免记录敏感信息。使用 HTTPS 传输敏感数据。

## 代码生成规则

### Controller 层
```java
@RestController
@RequestMapping("/api/v1/{resource}")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "{Resource} Management", description = "APIs for managing {resource}")
public class {Resource}Controller {
    
    private final {Resource}Service {resource}Service;
    
    @PostMapping
    @Operation(summary = "Create {resource}", description = "Create a new {resource}")
    public CommonResponse<{Resource}Response> create(@RequestBody @Valid Create{Resource}Request request) {
        // Implementation
    }
}
```

### Service 层
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class {Resource}ServiceImpl implements {Resource}Service {
    
    private final {Resource}Repository {resource}Repository;
    
    @Override
    @Transactional(readOnly = true)
    public CommonResponse<{Resource}Response> getById(Long id) {
        // Implementation
    }
}
```

### Entity 层
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "t_{resource}")
public class {Resource}Entity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "create_time", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createTime;
    
    @Column(name = "update_time", nullable = false)
    @UpdateTimestamp
    private LocalDateTime updateTime;
}
```

## 命名约定

### 包命名
- `com.{company}.{project}.controller` - 控制器
- `com.{company}.{project}.service` - 服务接口
- `com.{company}.{project}.service.impl` - 服务实现
- `com.{company}.{project}.dao.entity` - 实体类
- `com.{company}.{project}.dao.mapper` - 数据访问层
- `com.{company}.{project}.vo.request` - 请求对象
- `com.{company}.{project}.vo.response` - 响应对象

### 类命名
- Controller: `{Resource}Controller`
- Service: `{Resource}Service`, `{Resource}ServiceImpl`
- Entity: `{Resource}Entity`
- Mapper: `{Resource}Mapper`
- Request: `Create{Resource}Request`, `Update{Resource}Request`
- Response: `{Resource}Response`

### 方法命名
- 查询: `get{Resource}ById`, `list{Resource}s`, `find{Resource}s`
- 创建: `create{Resource}`
- 更新: `update{Resource}`
- 删除: `delete{Resource}ById`

## 错误处理

### 统一响应格式
```java
public class CommonResponse<T> {
    private Integer code;
    private String message;
    private T data;
    private Long timestamp;
}
```

### 异常处理
- 使用 `@ControllerAdvice` 进行全局异常处理
- 区分业务异常和系统异常
- 提供有意义的错误信息
- 记录详细的错误日志

## 测试要求

### 单元测试
- 测试覆盖率 > 80%
- 使用 Given-When-Then 模式
- Mock 外部依赖
- 测试边界条件

### 集成测试
- 使用 `@SpringBootTest`
- 测试完整的业务流程
- 使用测试数据库
- 清理测试数据

## 性能要求

### 数据库查询
- 避免 N+1 查询问题
- 使用适当的索引
- 实现分页查询
- 监控慢查询

### 缓存策略
- 使用 `@Cacheable` 缓存查询结果
- 合理设置缓存过期时间
- 实现缓存更新策略

## 安全要求

### 输入验证
- 使用 Bean Validation 注解
- 验证所有输入参数
- 防止 SQL 注入
- 防止 XSS 攻击

### 权限控制
- 实现基于角色的访问控制
- 使用 Spring Security
- 保护敏感接口
- 记录操作日志

## 文档要求

### API 文档
- 使用 Swagger 注解
- 提供完整的接口文档
- 包含请求/响应示例
- 描述错误码含义

### 代码文档
- 编写清晰的 JavaDoc
- 解释复杂的业务逻辑
- 提供使用示例
- 保持文档更新

## 部署要求

### 环境配置
- 使用 Profile 管理不同环境
- 外部化配置
- 使用配置中心
- 支持热更新

### 监控告警
- 集成应用监控
- 设置性能指标
- 实现健康检查
- 配置告警规则

---

*最后更新时间：2024年1月*
*版本：v3.0.0*