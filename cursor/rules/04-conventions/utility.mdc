---
description: 定义工具类的编码标准，包括类结构设计、方法实现和代码质量规范
globs: **/src/main/java/**/utils/**Util.java, **/src/main/java/**/util/**Util.java
layer: L4
allowedReferences: [L4]
---

# Utility 编码约定

## 适用范围
定义工具类的实现规范，提供通用的工具方法或服务。

## 工具类生成原则

### 根据项目需求决定
- **分析设计文档**：根据设计文档明确要求的功能生成工具类
- **分析技术选型**：根据技术栈生成相应工具类
- **行业最佳实践**：根据项目类型添加常见工具类

### 示例
- 如设计文档要求"JWT认证" → 生成 `JwtUtil`
- 如设计文档要求"密码加密" → 使用Spring Security的 `PasswordEncoder`（通过@Bean配置）
- 如项目需要"日期处理" → 生成 `DateUtil` 或使用Hutool
- 如项目需要"Redis缓存" → 生成 `RedisUtil`

## 核心规则

### 类型选择

**1. Spring组件型工具类（推荐）**
- 使用场景：需要注入配置、依赖其他Bean
- 注解：`@Component` 或 `@Service`
- 方法：非静态实例方法
- 示例：JwtUtil（需要读取配置）、RedisUtil（需要注入RedisTemplate）

**2. 纯静态工具类**
- 使用场景：无状态、纯函数计算
- 类修饰符：`final class`
- 构造器：`private`
- 方法：`public static`
- 示例：StringUtil、DateUtil

### 类定义规范

**Spring组件型**：
```java
@Component
@Slf4j
public class JwtUtil {
    @Value("${jwt.secret}")
    private String secret;
    
    public String generateToken(User user) { ... }
}
```

**纯静态型**：
```java
public final class StringUtil {
    private StringUtil() {}
    
    public static boolean isEmpty(String str) { ... }
}
```

### 方法设计
- 方法名清晰表达功能
- 参数验证（开始处）
- 返回类型明确（避免Object）
- 考虑线程安全
- 提供重载方法

### 异常处理
- 无效参数抛出 `IllegalArgumentException`
- 提供清晰的错误消息
- **可选**：必要时记录日志

### JavaDoc要求
- 类级别：说明工具类用途
- 方法级别：参数、返回值、异常、示例

## 常见工具类示例

### 1. JwtUtil（Spring组件型 - 推荐）

```java
package com.edu.spt.util;

import com.edu.spt.entity.UserEntity;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

/**
 * JWT工具类
 * 用于JWT令牌的生成、验证和信息提取
 */
@Component
@Slf4j
public class JwtUtil {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration:3600}")
    private Long expiration;
    
    /**
     * 生成JWT令牌
     */
    public String generateToken(UserEntity user) {
        Date now = new Date();
        Date expirationDate = new Date(now.getTime() + expiration * 1000);
        
        SecretKey key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
        
        return Jwts.builder()
                .setSubject(user.getId().toString())
                .claim("username", user.getUsername())
                .claim("role", user.getRole())
                .setIssuedAt(now)
                .setExpiration(expirationDate)
                .signWith(key, SignatureAlgorithm.HS256)
                .compact();
    }
    
    /**
     * 验证JWT令牌
     */
    public boolean validateToken(String token) {
        try {
            SecretKey key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            log.error("JWT验证失败", e);
            return false;
        }
    }
    
    /**
     * 从token获取用户ID
     */
    public Long getUserIdFromToken(String token) {
        Claims claims = getClaimsFromToken(token);
        return Long.parseLong(claims.getSubject());
    }
    
    private Claims getClaimsFromToken(String token) {
        SecretKey key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }
}
```

**配置文件（application.yml）**：
```yaml
jwt:
  secret: your-secret-key-at-least-256-bits-long
  expiration: 3600  # 1小时
```

### 2. DateUtil（静态工具类）

```java
/**
 * 日期工具类
 */
public final class DateUtil {
    
    private static final DateTimeFormatter DEFAULT_FORMATTER = 
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    
    private DateUtil() {}
    
    /**
     * 格式化日期
     */
    public static String format(LocalDateTime dateTime) {
        return dateTime != null ? dateTime.format(DEFAULT_FORMATTER) : null;
    }
    
    /**
     * 解析日期字符串
     */
    public static LocalDateTime parse(String dateStr) {
        return dateStr != null ? LocalDateTime.parse(dateStr, DEFAULT_FORMATTER) : null;
    }
}
```

### 3. RedisUtil（Spring组件型）

```java
/**
 * Redis工具类
 * 当项目使用Redis时生成此工具类
 */
@Component
@Slf4j
public class RedisUtil {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 设置缓存
     */
    public void set(String key, Object value, long timeout, TimeUnit unit) {
        redisTemplate.opsForValue().set(key, value, timeout, unit);
    }
    
    /**
     * 获取缓存
     */
    public Object get(String key) {
        return redisTemplate.opsForValue().get(key);
    }
}
```

## 最佳实践

### 1. 优先使用成熟库
- 字符串处理：使用 Hutool 的 `StrUtil`
- 日期处理：使用 Hutool 的 `DateUtil` 或 Java 8 Time API
- JSON处理：使用 Jackson 或 Gson
- HTTP请求：使用 Spring RestTemplate 或 Hutool HttpUtil

### 2. 单一职责
- 一个工具类只处理一类问题
- JWT工具只处理JWT，不要混入其他功能

### 3. 避免过度设计
- **禁止**：重复造轮子
- 只在确实需要时才创建工具类

### 4. 性能考虑
- 避免重复创建对象（使用静态实例或Spring单例）
- 考虑缓存计算结果
- 注意线程安全

### 5. 测试
- 工具类必须有完整的单元测试
- 目标覆盖率 ≥ 90%

## 工具类决策树

```
需要工具类？
├─ 是否需要配置/依赖注入？
│  ├─ 是 → 使用 @Component（JwtUtil、RedisUtil）
│  └─ 否 → 使用静态工具类（StringUtil、DateUtil）
├─ 是否有成熟库可用？
│  ├─ 是 → 直接使用（Hutool、Apache Commons）
│  └─ 否 → 自己实现
└─ 是否符合项目需求？
   ├─ 设计文档要求 → 必须生成
   └─ 可选功能 → 按需生成
```

## 常见工具类参考

| 工具类 | 类型 | 使用场景 | 示例 |
|-------|------|---------|------|
| JwtUtil | @Component | JWT认证项目 | 见上方示例 |
| RedisUtil | @Component | 使用Redis缓存 | 见上方示例 |
| DateUtil | static | 日期格式化 | 见上方示例 |
| StringUtil | static | 字符串处理 | 或使用Hutool |
| FileUtil | static | 文件操作 | 或使用Hutool |
| JsonUtil | static | JSON处理 | 或使用Jackson |
| ValidationUtil | static | 自定义验证逻辑 | 复杂业务校验 |
| EncryptUtil | static | 加密解密 | AES/RSA加密 |
| ImageUtil | static | 图片处理 | 压缩、裁剪、水印 |
| ExcelUtil | static | Excel导入导出 | 或使用EasyExcel |
| HttpClientUtil | static | HTTP请求 | 或使用RestTemplate |
| IdGeneratorUtil | static | ID生成 | 雪花算法、UUID |

## 相关规则
- 常量类: `04-conventions/constants.mdc`
